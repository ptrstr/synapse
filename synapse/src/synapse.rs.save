extern crate rand;
use rand::Rng;
use crate::neuron;

pub struct Synapse {
	neurons: Vec<Vec<neuron::Neuron>>,
	weights: Vec<Vec<f64>>,
}

impl Synapse {
	pub fn new(layers: Vec<usize>) -> Synapse {
		let mut neurons = vec![];
		
		let mut rng = rand::thread_rng();
		let mut weights = vec![];

		for i in 0..layers.len() {
			let mut neurons_vector = vec![];
			for j in 0..layers[i] {
				neurons_vector.push(neuron::Neuron::new());
			}

			neurons.push(neurons_vector);
			if i < layers.len() - 1 {
				weights.push(vec![rng.gen(); layers[i] * layers[i+1]]);
			}
		}

		Synapse {
			neurons: neurons,
			weights: weights,
		}
	}

	pub fn guess(&self, inputs: Vec<f64>) -> Vec<f64> {
		let mut artfacts:Vec<Vec<f64>> = vec![];
		for i in 0..self.neurons.len() {
			artifac
		}
	}
}
